// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`boolean list attribute 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/boolean_list.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface BooleanListConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/boolean_list.html#foo_required BooleanList#foo_required}
  */
  readonly fooRequired: cdktf.TerraformBooleanList;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/boolean_list.html#foo_optional BooleanList#foo_optional}
  */
  readonly fooOptional?: cdktf.TerraformBooleanList;
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/boolean_list.html aws_boolean_list}
*/
export class BooleanList extends cdktf.TerraformResource {

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/boolean_list.html aws_boolean_list} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options BooleanListConfig
  */
  public constructor(scope: Construct, id: string, config: BooleanListConfig) {
    super(scope, id, {
      terraformResourceType: 'aws_boolean_list',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this.putFooRequired(config.fooRequired);
    this.putFooOptional(config.fooOptional ?? new cdktf.TerraformBooleanListAttribute(this, 'foo_optional', undefined));
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // foo_required - computed: false, optional: false, required: true
  private _fooRequired!: cdktf.TerraformBooleanListAttribute;
  public get fooRequired() {
    return this._fooRequired;
  }
  public putFooRequired(value: cdktf.TerraformBooleanList) {
    this._fooRequired = cdktf.TerraformBooleanListAttribute.create(this, 'foo_required', value);
  }

  // foo_optional - computed: false, optional: true, required: false
  private _fooOptional!: cdktf.TerraformBooleanListAttribute;
  public get fooOptional() {
    return this._fooOptional;
  }
  public putFooOptional(value: cdktf.TerraformBooleanList | undefined) {
    if (value === undefined) {
      this._fooOptional.reset();
    }
    else {
      this._fooOptional = cdktf.TerraformBooleanListAttribute.create(this, 'foo_optional', value);
    }
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      foo_required: this._fooRequired.toTerraform(),
      foo_optional: this._fooOptional.toTerraform(),
    };
  }
}
"
`;

exports[`boolean map attribute 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/boolean_map.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface BooleanMapConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/boolean_map.html#foo_computed_optional BooleanMap#foo_computed_optional}
  */
  readonly fooComputedOptional?: cdktf.TerraformBooleanMap;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/boolean_map.html#foo_optional BooleanMap#foo_optional}
  */
  readonly fooOptional?: cdktf.TerraformBooleanMap;
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/boolean_map.html aws_boolean_map}
*/
export class BooleanMap extends cdktf.TerraformResource {

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/boolean_map.html aws_boolean_map} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options BooleanMapConfig = {}
  */
  public constructor(scope: Construct, id: string, config: BooleanMapConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_boolean_map',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this._fooComputed = new cdktf.TerraformBooleanMapAttribute(this, 'foo_computed', undefined)
    this.putFooComputedOptional(config.fooComputedOptional ?? new cdktf.TerraformBooleanMapAttribute(this, 'foo_computed_optional', undefined));
    this.putFooOptional(config.fooOptional ?? new cdktf.TerraformBooleanMapAttribute(this, 'foo_optional', undefined));
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // foo_computed - computed: true, optional: false, required: false
  private _fooComputed: cdktf.TerraformBooleanMapAttribute;
  public get fooComputed() {
    return this._fooComputed;
  }

  // foo_computed_optional - computed: true, optional: true, required: false
  private _fooComputedOptional!: cdktf.TerraformBooleanMapAttribute;
  public get fooComputedOptional() {
    return this._fooComputedOptional;
  }
  public putFooComputedOptional(value: cdktf.TerraformBooleanMap | undefined) {
    if (value === undefined) {
      this._fooComputedOptional.reset();
    }
    else {
      this._fooComputedOptional = cdktf.TerraformBooleanMapAttribute.create(this, 'foo_computed_optional', value);
    }
  }

  // foo_optional - computed: false, optional: true, required: false
  private _fooOptional!: cdktf.TerraformBooleanMapAttribute;
  public get fooOptional() {
    return this._fooOptional;
  }
  public putFooOptional(value: cdktf.TerraformBooleanMap | undefined) {
    if (value === undefined) {
      this._fooOptional.reset();
    }
    else {
      this._fooOptional = cdktf.TerraformBooleanMapAttribute.create(this, 'foo_optional', value);
    }
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      foo_computed_optional: this._fooComputedOptional.toTerraform(),
      foo_optional: this._fooOptional.toTerraform(),
    };
  }
}
"
`;

exports[`computed complex attribute 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/computed_complex.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface ComputedComplexConfig extends cdktf.TerraformMetaArguments {
}
export class ComputedComplexEgress extends cdktf.ComplexComputedList {

  // cidr_blocks - computed: true, optional: false, required: false
  private _cidrBlocks: cdktf.TerraformStringListAttribute;
  public get cidrBlocks() {
    return this._cidrBlocks;
  }

  // description - computed: true, optional: false, required: false
  private _description: cdktf.TerraformStringAttribute;
  public get description() {
    return this._description;
  }

  // from_port - computed: true, optional: false, required: false
  private _fromPort: cdktf.TerraformNumberAttribute;
  public get fromPort() {
    return this._fromPort;
  }

  // ipv6_cidr_blocks - computed: true, optional: false, required: false
  private _ipv6CidrBlocks: cdktf.TerraformStringListAttribute;
  public get ipv6CidrBlocks() {
    return this._ipv6CidrBlocks;
  }

  // prefix_list_ids - computed: true, optional: false, required: false
  private _prefixListIds: cdktf.TerraformStringListAttribute;
  public get prefixListIds() {
    return this._prefixListIds;
  }

  // protocol - computed: true, optional: false, required: false
  private _protocol: cdktf.TerraformStringAttribute;
  public get protocol() {
    return this._protocol;
  }

  // security_groups - computed: true, optional: false, required: false
  private _securityGroups: cdktf.TerraformStringSetAttribute;
  public get securityGroups() {
    return this._securityGroups;
  }

  // self - computed: true, optional: false, required: false
  private _self: cdktf.TerraformBooleanAttribute;
  public get selfAttribute() {
    return this._self;
  }

  // to_port - computed: true, optional: false, required: false
  private _toPort: cdktf.TerraformNumberAttribute;
  public get toPort() {
    return this._toPort;
  }
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/computed_complex.html aws_computed_complex}
*/
export class ComputedComplex extends cdktf.TerraformResource {

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/computed_complex.html aws_computed_complex} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options ComputedComplexConfig = {}
  */
  public constructor(scope: Construct, id: string, config: ComputedComplexConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_computed_complex',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this._egress = new TerraformComputedComplexEgressSetAttribute(this, 'egress', undefined)
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // egress - computed: true, optional: false, required: false
  private _egress: TerraformComputedComplexEgressSetAttribute;
  public get egress() {
    return this._egress;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
    };
  }
}
"
`;

exports[`computed complex nested attribute 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/computed_complex_nested.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface ComputedComplexNestedConfig extends cdktf.TerraformMetaArguments {
}
export class ComputedComplexNestedResourcesAutoscalingGroups extends cdktf.ComplexComputedList {

  // name - computed: true, optional: false, required: false
  private _name: cdktf.TerraformStringAttribute;
  public get name() {
    return this._name;
  }
}
export class ComputedComplexNestedResources extends cdktf.ComplexComputedList {

  // autoscaling_groups - computed: true, optional: false, required: false
  private _autoscalingGroups: TerraformComputedComplexNestedResourcesAutoscalingGroupsListAttribute;
  public get autoscalingGroups() {
    return this._autoscalingGroups;
  }

  // remote_access_security_group_id - computed: true, optional: false, required: false
  private _remoteAccessSecurityGroupId: cdktf.TerraformStringAttribute;
  public get remoteAccessSecurityGroupId() {
    return this._remoteAccessSecurityGroupId;
  }
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/computed_complex_nested.html aws_computed_complex_nested}
*/
export class ComputedComplexNested extends cdktf.TerraformResource {

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/computed_complex_nested.html aws_computed_complex_nested} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options ComputedComplexNestedConfig = {}
  */
  public constructor(scope: Construct, id: string, config: ComputedComplexNestedConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_computed_complex_nested',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this._resources = new TerraformComputedComplexNestedResourcesListAttribute(this, 'resources', undefined)
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // resources - computed: true, optional: false, required: false
  private _resources: TerraformComputedComplexNestedResourcesListAttribute;
  public get resources() {
    return this._resources;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
    };
  }
}
"
`;

exports[`computed nested complex list block type 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/block_type_nested_computed_list.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface BlockTypeNestedComputedListConfig extends cdktf.TerraformMetaArguments {
  /**
  * inputs block
  * 
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/block_type_nested_computed_list.html#inputs BlockTypeNestedComputedList#inputs}
  */
  readonly inputs?: TerraformBlockTypeNestedComputedListInputsList;
}
export class BlockTypeNestedComputedListInputsStartingPositionConfiguration extends cdktf.ComplexComputedList {

  // starting_position - computed: true, optional: false, required: false
  private _startingPosition: cdktf.TerraformStringAttribute;
  public get startingPosition() {
    return this._startingPosition;
  }
}
export interface BlockTypeNestedComputedListInputs {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/block_type_nested_computed_list.html#id BlockTypeNestedComputedList#id}
  */
  readonly id?: cdktf.TerraformString;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/block_type_nested_computed_list.html#name_prefix BlockTypeNestedComputedList#name_prefix}
  */
  readonly namePrefix: cdktf.TerraformString;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/block_type_nested_computed_list.html#starting_position_configuration BlockTypeNestedComputedList#starting_position_configuration}
  */
  readonly startingPositionConfiguration?: TerraformBlockTypeNestedComputedListInputsStartingPositionConfigurationList;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/block_type_nested_computed_list.html#stream_names BlockTypeNestedComputedList#stream_names}
  */
  readonly streamNames?: cdktf.TerraformStringSet;
}

function blockTypeNestedComputedListInputsToTerraform(struct?: BlockTypeNestedComputedListInputs): any {
  if (!cdktf.canInspect(struct)) { return struct; }
  return {
    name_prefix: struct!.namePrefix.toTerraform(),
  }
}


/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/block_type_nested_computed_list.html aws_block_type_nested_computed_list}
*/
export class BlockTypeNestedComputedList extends cdktf.TerraformResource {

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/block_type_nested_computed_list.html aws_block_type_nested_computed_list} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options BlockTypeNestedComputedListConfig = {}
  */
  public constructor(scope: Construct, id: string, config: BlockTypeNestedComputedListConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_block_type_nested_computed_list',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this.putInputs(config.inputs ?? new TerraformBlockTypeNestedComputedListInputsListAttribute(this, 'inputs', undefined));
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // inputs - computed: false, optional: true, required: false
  private _inputs!: TerraformBlockTypeNestedComputedListInputsListAttribute;
  public get inputs() {
    return this._inputs;
  }
  public putInputs(value: TerraformBlockTypeNestedComputedListInputsList | undefined) {
    if (value === undefined) {
      this._inputs.reset();
    }
    else {
      this._inputs = TerraformBlockTypeNestedComputedListInputsListAttribute.create(this, 'inputs', value);
    }
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      inputs: this._inputs.toTerraform(),
    };
  }
}
"
`;

exports[`computed optional complex attribute 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/computed_optional_complex.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface ComputedOptionalComplexConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/computed_optional_complex.html#egress ComputedOptionalComplex#egress}
  */
  readonly egress?: TerraformComputedOptionalComplexEgressSet;
}
export interface ComputedOptionalComplexEgress {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/computed_optional_complex.html#cidr_blocks ComputedOptionalComplex#cidr_blocks}
  */
  readonly cidrBlocks?: cdktf.TerraformStringList;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/computed_optional_complex.html#description ComputedOptionalComplex#description}
  */
  readonly description?: cdktf.TerraformString;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/computed_optional_complex.html#from_port ComputedOptionalComplex#from_port}
  */
  readonly fromPort?: cdktf.TerraformNumber;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/computed_optional_complex.html#ipv6_cidr_blocks ComputedOptionalComplex#ipv6_cidr_blocks}
  */
  readonly ipv6CidrBlocks?: cdktf.TerraformStringList;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/computed_optional_complex.html#prefix_list_ids ComputedOptionalComplex#prefix_list_ids}
  */
  readonly prefixListIds?: cdktf.TerraformStringList;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/computed_optional_complex.html#protocol ComputedOptionalComplex#protocol}
  */
  readonly protocol?: cdktf.TerraformString;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/computed_optional_complex.html#security_groups ComputedOptionalComplex#security_groups}
  */
  readonly securityGroups?: cdktf.TerraformStringSet;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/computed_optional_complex.html#self ComputedOptionalComplex#self}
  */
  readonly selfAttribute?: cdktf.TerraformBoolean;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/computed_optional_complex.html#to_port ComputedOptionalComplex#to_port}
  */
  readonly toPort?: cdktf.TerraformNumber;
}

function computedOptionalComplexEgressToTerraform(struct?: ComputedOptionalComplexEgress): any {
  if (!cdktf.canInspect(struct)) { return struct; }
  return {
    cidr_blocks: struct!.cidrBlocks.toTerraform(),
    description: struct!.description.toTerraform(),
    from_port: struct!.fromPort.toTerraform(),
    ipv6_cidr_blocks: struct!.ipv6CidrBlocks.toTerraform(),
    prefix_list_ids: struct!.prefixListIds.toTerraform(),
    protocol: struct!.protocol.toTerraform(),
    security_groups: struct!.securityGroups.toTerraform(),
    self: struct!.selfAttribute.toTerraform(),
    to_port: struct!.toPort.toTerraform(),
  }
}


/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/computed_optional_complex.html aws_computed_optional_complex}
*/
export class ComputedOptionalComplex extends cdktf.TerraformResource {

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/computed_optional_complex.html aws_computed_optional_complex} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options ComputedOptionalComplexConfig = {}
  */
  public constructor(scope: Construct, id: string, config: ComputedOptionalComplexConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_computed_optional_complex',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this.putEgress(config.egress ?? new TerraformComputedOptionalComplexEgressSetAttribute(this, 'egress', undefined));
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // egress - computed: true, optional: true, required: false
  private _egress!: TerraformComputedOptionalComplexEgressSetAttribute;
  public get egress() {
    return this._egress;
  }
  public putEgress(value: TerraformComputedOptionalComplexEgressSet | undefined) {
    if (value === undefined) {
      this._egress.reset();
    }
    else {
      this._egress = TerraformComputedOptionalComplexEgressSetAttribute.create(this, 'egress', value);
    }
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      egress: this._egress.toTerraform(),
    };
  }
}
"
`;

exports[`deeply nested block types 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/deeply_nested_block_types.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface DeeplyNestedBlockTypesConfig extends cdktf.TerraformMetaArguments {
  /**
  * lifecycle_rule block
  * 
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/deeply_nested_block_types.html#lifecycle_rule DeeplyNestedBlockTypes#lifecycle_rule}
  */
  readonly lifecycleRule?: TerraformDeeplyNestedBlockTypesLifecycleRuleList;
}
export interface DeeplyNestedBlockTypesLifecycleRuleExpiration {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/deeply_nested_block_types.html#date DeeplyNestedBlockTypes#date}
  */
  readonly date?: cdktf.TerraformString;
}

function deeplyNestedBlockTypesLifecycleRuleExpirationToTerraform(struct?: DeeplyNestedBlockTypesLifecycleRuleExpiration): any {
  if (!cdktf.canInspect(struct)) { return struct; }
  return {
    date: struct!.date.toTerraform(),
  }
}

export interface DeeplyNestedBlockTypesLifecycleRule {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/deeply_nested_block_types.html#abort_incomplete_multipart_upload_days DeeplyNestedBlockTypes#abort_incomplete_multipart_upload_days}
  */
  readonly abortIncompleteMultipartUploadDays?: cdktf.TerraformNumber;
  /**
  * expiration block
  * 
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/deeply_nested_block_types.html#expiration DeeplyNestedBlockTypes#expiration}
  */
  readonly expiration?: TerraformDeeplyNestedBlockTypesLifecycleRuleExpirationSet;
}

function deeplyNestedBlockTypesLifecycleRuleToTerraform(struct?: DeeplyNestedBlockTypesLifecycleRule): any {
  if (!cdktf.canInspect(struct)) { return struct; }
  return {
    abort_incomplete_multipart_upload_days: struct!.abortIncompleteMultipartUploadDays.toTerraform(),
    expiration: struct!.expiration.toTerraform(),
  }
}


/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/deeply_nested_block_types.html aws_deeply_nested_block_types}
*/
export class DeeplyNestedBlockTypes extends cdktf.TerraformResource {

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/deeply_nested_block_types.html aws_deeply_nested_block_types} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options DeeplyNestedBlockTypesConfig = {}
  */
  public constructor(scope: Construct, id: string, config: DeeplyNestedBlockTypesConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_deeply_nested_block_types',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this.putLifecycleRule(config.lifecycleRule ?? new TerraformDeeplyNestedBlockTypesLifecycleRuleListAttribute(this, 'lifecycle_rule', undefined));
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // lifecycle_rule - computed: false, optional: true, required: false
  private _lifecycleRule!: TerraformDeeplyNestedBlockTypesLifecycleRuleListAttribute;
  public get lifecycleRule() {
    return this._lifecycleRule;
  }
  public putLifecycleRule(value: TerraformDeeplyNestedBlockTypesLifecycleRuleList | undefined) {
    if (value === undefined) {
      this._lifecycleRule.reset();
    }
    else {
      this._lifecycleRule = TerraformDeeplyNestedBlockTypesLifecycleRuleListAttribute.create(this, 'lifecycle_rule', value);
    }
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      lifecycle_rule: this._lifecycleRule.toTerraform(),
    };
  }
}
"
`;

exports[`ignored attributes 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/ignored_attributes.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface IgnoredAttributesConfig extends cdktf.TerraformMetaArguments {
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/ignored_attributes.html aws_ignored_attributes}
*/
export class IgnoredAttributes extends cdktf.TerraformResource {

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/ignored_attributes.html aws_ignored_attributes} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options IgnoredAttributesConfig = {}
  */
  public constructor(scope: Construct, id: string, config: IgnoredAttributesConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_ignored_attributes',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this._id = new cdktf.TerraformStringAttribute(this, 'id', undefined)
    this._arn = new cdktf.TerraformStringAttribute(this, 'arn', undefined)
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // id - computed: true, optional: true, required: false
  private _id: cdktf.TerraformStringAttribute;
  public get id() {
    return this._id;
  }

  // arn - computed: true, optional: false, required: false
  private _arn: cdktf.TerraformStringAttribute;
  public get arn() {
    return this._arn;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
    };
  }
}
"
`;

exports[`incompatible attribute names 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/incompatible_attribute_names.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface IncompatibleAttributeNamesConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/incompatible_attribute_names.html#get_password_data IncompatibleAttributeNames#get_password_data}
  */
  readonly fetchPasswordData?: cdktf.TerraformString;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/incompatible_attribute_names.html#self IncompatibleAttributeNames#self}
  */
  readonly selfAttribute: cdktf.TerraformString;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/incompatible_attribute_names.html#equals IncompatibleAttributeNames#equals}
  */
  readonly equalTo: cdktf.TerraformString;
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/incompatible_attribute_names.html aws_incompatible_attribute_names}
*/
export class IncompatibleAttributeNames extends cdktf.TerraformResource {

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/incompatible_attribute_names.html aws_incompatible_attribute_names} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options IncompatibleAttributeNamesConfig
  */
  public constructor(scope: Construct, id: string, config: IncompatibleAttributeNamesConfig) {
    super(scope, id, {
      terraformResourceType: 'aws_incompatible_attribute_names',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this.putFetchPasswordData(config.fetchPasswordData ?? new cdktf.TerraformStringAttribute(this, 'get_password_data', undefined));
    this.putSelfAttribute(config.selfAttribute);
    this.putEqualTo(config.equalTo);
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // get_password_data - computed: false, optional: true, required: false
  private _getPasswordData!: cdktf.TerraformStringAttribute;
  public get fetchPasswordData() {
    return this._getPasswordData;
  }
  public putFetchPasswordData(value: cdktf.TerraformString | undefined) {
    if (value === undefined) {
      this._getPasswordData.reset();
    }
    else {
      this._getPasswordData = cdktf.TerraformStringAttribute.create(this, 'get_password_data', value);
    }
  }

  // self - computed: false, optional: false, required: true
  private _self!: cdktf.TerraformStringAttribute;
  public get selfAttribute() {
    return this._self;
  }
  public putSelfAttribute(value: cdktf.TerraformString) {
    this._self = cdktf.TerraformStringAttribute.create(this, 'self', value);
  }

  // equals - computed: false, optional: false, required: true
  private _equals!: cdktf.TerraformStringAttribute;
  public get equalTo() {
    return this._equals;
  }
  public putEqualTo(value: cdktf.TerraformString) {
    this._equals = cdktf.TerraformStringAttribute.create(this, 'equals', value);
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      get_password_data: this._getPasswordData.toTerraform(),
      self: this._self.toTerraform(),
      equals: this._equals.toTerraform(),
    };
  }
}
"
`;

exports[`list of string map attribute 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/list_of_string_map.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface ListOfStringMapConfig extends cdktf.TerraformMetaArguments {
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/list_of_string_map.html aws_list_of_string_map}
*/
export class ListOfStringMap extends cdktf.TerraformResource {

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/list_of_string_map.html aws_list_of_string_map} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options ListOfStringMapConfig = {}
  */
  public constructor(scope: Construct, id: string, config: ListOfStringMapConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_list_of_string_map',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this._keys = new cdktf.TerraformStringListAttribute(this, 'keys', undefined)
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // keys - computed: true, optional: false, required: false
  private _keys: cdktf.TerraformStringListAttribute;
  public get keys() {
    return this._keys;
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
    };
  }
}
"
`;

exports[`number list attribute 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/number_list.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface NumberListConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/number_list.html#foo_required NumberList#foo_required}
  */
  readonly fooRequired: cdktf.TerraformNumberList;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/number_list.html#foo_optional NumberList#foo_optional}
  */
  readonly fooOptional?: cdktf.TerraformNumberList;
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/number_list.html aws_number_list}
*/
export class NumberList extends cdktf.TerraformResource {

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/number_list.html aws_number_list} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options NumberListConfig
  */
  public constructor(scope: Construct, id: string, config: NumberListConfig) {
    super(scope, id, {
      terraformResourceType: 'aws_number_list',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this.putFooRequired(config.fooRequired);
    this.putFooOptional(config.fooOptional ?? new cdktf.TerraformNumberListAttribute(this, 'foo_optional', undefined));
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // foo_required - computed: false, optional: false, required: true
  private _fooRequired!: cdktf.TerraformNumberListAttribute;
  public get fooRequired() {
    return this._fooRequired;
  }
  public putFooRequired(value: cdktf.TerraformNumberList) {
    this._fooRequired = cdktf.TerraformNumberListAttribute.create(this, 'foo_required', value);
  }

  // foo_optional - computed: false, optional: true, required: false
  private _fooOptional!: cdktf.TerraformNumberListAttribute;
  public get fooOptional() {
    return this._fooOptional;
  }
  public putFooOptional(value: cdktf.TerraformNumberList | undefined) {
    if (value === undefined) {
      this._fooOptional.reset();
    }
    else {
      this._fooOptional = cdktf.TerraformNumberListAttribute.create(this, 'foo_optional', value);
    }
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      foo_required: this._fooRequired.toTerraform(),
      foo_optional: this._fooOptional.toTerraform(),
    };
  }
}
"
`;

exports[`number map attribute 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/number_map.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface NumberMapConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/number_map.html#foo_computed_optional NumberMap#foo_computed_optional}
  */
  readonly fooComputedOptional?: cdktf.TerraformNumberMap;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/number_map.html#foo_optional NumberMap#foo_optional}
  */
  readonly fooOptional?: cdktf.TerraformNumberMap;
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/number_map.html aws_number_map}
*/
export class NumberMap extends cdktf.TerraformResource {

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/number_map.html aws_number_map} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options NumberMapConfig = {}
  */
  public constructor(scope: Construct, id: string, config: NumberMapConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_number_map',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this._fooComputed = new cdktf.TerraformNumberMapAttribute(this, 'foo_computed', undefined)
    this.putFooComputedOptional(config.fooComputedOptional ?? new cdktf.TerraformNumberMapAttribute(this, 'foo_computed_optional', undefined));
    this.putFooOptional(config.fooOptional ?? new cdktf.TerraformNumberMapAttribute(this, 'foo_optional', undefined));
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // foo_computed - computed: true, optional: false, required: false
  private _fooComputed: cdktf.TerraformNumberMapAttribute;
  public get fooComputed() {
    return this._fooComputed;
  }

  // foo_computed_optional - computed: true, optional: true, required: false
  private _fooComputedOptional!: cdktf.TerraformNumberMapAttribute;
  public get fooComputedOptional() {
    return this._fooComputedOptional;
  }
  public putFooComputedOptional(value: cdktf.TerraformNumberMap | undefined) {
    if (value === undefined) {
      this._fooComputedOptional.reset();
    }
    else {
      this._fooComputedOptional = cdktf.TerraformNumberMapAttribute.create(this, 'foo_computed_optional', value);
    }
  }

  // foo_optional - computed: false, optional: true, required: false
  private _fooOptional!: cdktf.TerraformNumberMapAttribute;
  public get fooOptional() {
    return this._fooOptional;
  }
  public putFooOptional(value: cdktf.TerraformNumberMap | undefined) {
    if (value === undefined) {
      this._fooOptional.reset();
    }
    else {
      this._fooOptional = cdktf.TerraformNumberMapAttribute.create(this, 'foo_optional', value);
    }
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      foo_computed_optional: this._fooComputedOptional.toTerraform(),
      foo_optional: this._fooOptional.toTerraform(),
    };
  }
}
"
`;

exports[`primitive boolean 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/primitive_boolean.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface PrimitiveBooleanConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/primitive_boolean.html#foo_computed_optional PrimitiveBoolean#foo_computed_optional}
  */
  readonly fooComputedOptional?: cdktf.TerraformBoolean;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/primitive_boolean.html#foo_optional PrimitiveBoolean#foo_optional}
  */
  readonly fooOptional?: cdktf.TerraformBoolean;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/primitive_boolean.html#foo_required PrimitiveBoolean#foo_required}
  */
  readonly fooRequired: cdktf.TerraformBoolean;
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/primitive_boolean.html aws_primitive_boolean}
*/
export class PrimitiveBoolean extends cdktf.TerraformResource {

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/primitive_boolean.html aws_primitive_boolean} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options PrimitiveBooleanConfig
  */
  public constructor(scope: Construct, id: string, config: PrimitiveBooleanConfig) {
    super(scope, id, {
      terraformResourceType: 'aws_primitive_boolean',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this._fooComputed = new cdktf.TerraformBooleanAttribute(this, 'foo_computed', undefined)
    this.putFooComputedOptional(config.fooComputedOptional ?? new cdktf.TerraformBooleanAttribute(this, 'foo_computed_optional', undefined));
    this.putFooOptional(config.fooOptional ?? new cdktf.TerraformBooleanAttribute(this, 'foo_optional', undefined));
    this.putFooRequired(config.fooRequired);
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // foo_computed - computed: true, optional: false, required: false
  private _fooComputed: cdktf.TerraformBooleanAttribute;
  public get fooComputed() {
    return this._fooComputed;
  }

  // foo_computed_optional - computed: true, optional: true, required: false
  private _fooComputedOptional!: cdktf.TerraformBooleanAttribute;
  public get fooComputedOptional() {
    return this._fooComputedOptional;
  }
  public putFooComputedOptional(value: cdktf.TerraformBoolean | undefined) {
    if (value === undefined) {
      this._fooComputedOptional.reset();
    }
    else {
      this._fooComputedOptional = cdktf.TerraformBooleanAttribute.create(this, 'foo_computed_optional', value);
    }
  }

  // foo_optional - computed: false, optional: true, required: false
  private _fooOptional!: cdktf.TerraformBooleanAttribute;
  public get fooOptional() {
    return this._fooOptional;
  }
  public putFooOptional(value: cdktf.TerraformBoolean | undefined) {
    if (value === undefined) {
      this._fooOptional.reset();
    }
    else {
      this._fooOptional = cdktf.TerraformBooleanAttribute.create(this, 'foo_optional', value);
    }
  }

  // foo_required - computed: false, optional: false, required: true
  private _fooRequired!: cdktf.TerraformBooleanAttribute;
  public get fooRequired() {
    return this._fooRequired;
  }
  public putFooRequired(value: cdktf.TerraformBoolean) {
    this._fooRequired = cdktf.TerraformBooleanAttribute.create(this, 'foo_required', value);
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      foo_computed_optional: this._fooComputedOptional.toTerraform(),
      foo_optional: this._fooOptional.toTerraform(),
      foo_required: this._fooRequired.toTerraform(),
    };
  }
}
"
`;

exports[`primitive dynamic 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/primitive_dynamic.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface PrimitiveDynamicConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/primitive_dynamic.html#foo_computed_optional PrimitiveDynamic#foo_computed_optional}
  */
  readonly fooComputedOptional?: cdktf.TerraformDynamic;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/primitive_dynamic.html#foo_optional PrimitiveDynamic#foo_optional}
  */
  readonly fooOptional?: cdktf.TerraformDynamic;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/primitive_dynamic.html#foo_required PrimitiveDynamic#foo_required}
  */
  readonly fooRequired: cdktf.TerraformDynamic;
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/primitive_dynamic.html aws_primitive_dynamic}
*/
export class PrimitiveDynamic extends cdktf.TerraformResource {

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/primitive_dynamic.html aws_primitive_dynamic} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options PrimitiveDynamicConfig
  */
  public constructor(scope: Construct, id: string, config: PrimitiveDynamicConfig) {
    super(scope, id, {
      terraformResourceType: 'aws_primitive_dynamic',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this._fooComputed = new cdktf.TerraformDynamicAttribute(this, 'foo_computed', undefined)
    this.putFooComputedOptional(config.fooComputedOptional ?? new cdktf.TerraformDynamicAttribute(this, 'foo_computed_optional', undefined));
    this.putFooOptional(config.fooOptional ?? new cdktf.TerraformDynamicAttribute(this, 'foo_optional', undefined));
    this.putFooRequired(config.fooRequired);
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // foo_computed - computed: true, optional: false, required: false
  private _fooComputed: cdktf.TerraformDynamicAttribute;
  public get fooComputed() {
    return this._fooComputed;
  }

  // foo_computed_optional - computed: true, optional: true, required: false
  private _fooComputedOptional!: cdktf.TerraformDynamicAttribute;
  public get fooComputedOptional() {
    return this._fooComputedOptional;
  }
  public putFooComputedOptional(value: cdktf.TerraformDynamic | undefined) {
    if (value === undefined) {
      this._fooComputedOptional.reset();
    }
    else {
      this._fooComputedOptional = cdktf.TerraformDynamicAttribute.create(this, 'foo_computed_optional', value);
    }
  }

  // foo_optional - computed: false, optional: true, required: false
  private _fooOptional!: cdktf.TerraformDynamicAttribute;
  public get fooOptional() {
    return this._fooOptional;
  }
  public putFooOptional(value: cdktf.TerraformDynamic | undefined) {
    if (value === undefined) {
      this._fooOptional.reset();
    }
    else {
      this._fooOptional = cdktf.TerraformDynamicAttribute.create(this, 'foo_optional', value);
    }
  }

  // foo_required - computed: false, optional: false, required: true
  private _fooRequired!: cdktf.TerraformDynamicAttribute;
  public get fooRequired() {
    return this._fooRequired;
  }
  public putFooRequired(value: cdktf.TerraformDynamic) {
    this._fooRequired = cdktf.TerraformDynamicAttribute.create(this, 'foo_required', value);
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      foo_computed_optional: this._fooComputedOptional.toTerraform(),
      foo_optional: this._fooOptional.toTerraform(),
      foo_required: this._fooRequired.toTerraform(),
    };
  }
}
"
`;

exports[`primitive number 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/primitive_number.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface PrimitiveNumberConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/primitive_number.html#foo_computed_optional PrimitiveNumber#foo_computed_optional}
  */
  readonly fooComputedOptional?: cdktf.TerraformNumber;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/primitive_number.html#foo_optional PrimitiveNumber#foo_optional}
  */
  readonly fooOptional?: cdktf.TerraformNumber;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/primitive_number.html#foo_required PrimitiveNumber#foo_required}
  */
  readonly fooRequired: cdktf.TerraformNumber;
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/primitive_number.html aws_primitive_number}
*/
export class PrimitiveNumber extends cdktf.TerraformResource {

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/primitive_number.html aws_primitive_number} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options PrimitiveNumberConfig
  */
  public constructor(scope: Construct, id: string, config: PrimitiveNumberConfig) {
    super(scope, id, {
      terraformResourceType: 'aws_primitive_number',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this._fooComputed = new cdktf.TerraformNumberAttribute(this, 'foo_computed', undefined)
    this.putFooComputedOptional(config.fooComputedOptional ?? new cdktf.TerraformNumberAttribute(this, 'foo_computed_optional', undefined));
    this.putFooOptional(config.fooOptional ?? new cdktf.TerraformNumberAttribute(this, 'foo_optional', undefined));
    this.putFooRequired(config.fooRequired);
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // foo_computed - computed: true, optional: false, required: false
  private _fooComputed: cdktf.TerraformNumberAttribute;
  public get fooComputed() {
    return this._fooComputed;
  }

  // foo_computed_optional - computed: true, optional: true, required: false
  private _fooComputedOptional!: cdktf.TerraformNumberAttribute;
  public get fooComputedOptional() {
    return this._fooComputedOptional;
  }
  public putFooComputedOptional(value: cdktf.TerraformNumber | undefined) {
    if (value === undefined) {
      this._fooComputedOptional.reset();
    }
    else {
      this._fooComputedOptional = cdktf.TerraformNumberAttribute.create(this, 'foo_computed_optional', value);
    }
  }

  // foo_optional - computed: false, optional: true, required: false
  private _fooOptional!: cdktf.TerraformNumberAttribute;
  public get fooOptional() {
    return this._fooOptional;
  }
  public putFooOptional(value: cdktf.TerraformNumber | undefined) {
    if (value === undefined) {
      this._fooOptional.reset();
    }
    else {
      this._fooOptional = cdktf.TerraformNumberAttribute.create(this, 'foo_optional', value);
    }
  }

  // foo_required - computed: false, optional: false, required: true
  private _fooRequired!: cdktf.TerraformNumberAttribute;
  public get fooRequired() {
    return this._fooRequired;
  }
  public putFooRequired(value: cdktf.TerraformNumber) {
    this._fooRequired = cdktf.TerraformNumberAttribute.create(this, 'foo_required', value);
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      foo_computed_optional: this._fooComputedOptional.toTerraform(),
      foo_optional: this._fooOptional.toTerraform(),
      foo_required: this._fooRequired.toTerraform(),
    };
  }
}
"
`;

exports[`primitive string 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/primitive_string.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface PrimitiveStringConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/primitive_string.html#foo_computed_optional PrimitiveString#foo_computed_optional}
  */
  readonly fooComputedOptional?: cdktf.TerraformString;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/primitive_string.html#foo_optional PrimitiveString#foo_optional}
  */
  readonly fooOptional?: cdktf.TerraformString;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/primitive_string.html#foo_required PrimitiveString#foo_required}
  */
  readonly fooRequired: cdktf.TerraformString;
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/primitive_string.html aws_primitive_string}
*/
export class PrimitiveString extends cdktf.TerraformResource {

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/primitive_string.html aws_primitive_string} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options PrimitiveStringConfig
  */
  public constructor(scope: Construct, id: string, config: PrimitiveStringConfig) {
    super(scope, id, {
      terraformResourceType: 'aws_primitive_string',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this._fooComputed = new cdktf.TerraformStringAttribute(this, 'foo_computed', undefined)
    this.putFooComputedOptional(config.fooComputedOptional ?? new cdktf.TerraformStringAttribute(this, 'foo_computed_optional', undefined));
    this.putFooOptional(config.fooOptional ?? new cdktf.TerraformStringAttribute(this, 'foo_optional', undefined));
    this.putFooRequired(config.fooRequired);
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // foo_computed - computed: true, optional: false, required: false
  private _fooComputed: cdktf.TerraformStringAttribute;
  public get fooComputed() {
    return this._fooComputed;
  }

  // foo_computed_optional - computed: true, optional: true, required: false
  private _fooComputedOptional!: cdktf.TerraformStringAttribute;
  public get fooComputedOptional() {
    return this._fooComputedOptional;
  }
  public putFooComputedOptional(value: cdktf.TerraformString | undefined) {
    if (value === undefined) {
      this._fooComputedOptional.reset();
    }
    else {
      this._fooComputedOptional = cdktf.TerraformStringAttribute.create(this, 'foo_computed_optional', value);
    }
  }

  // foo_optional - computed: false, optional: true, required: false
  private _fooOptional!: cdktf.TerraformStringAttribute;
  public get fooOptional() {
    return this._fooOptional;
  }
  public putFooOptional(value: cdktf.TerraformString | undefined) {
    if (value === undefined) {
      this._fooOptional.reset();
    }
    else {
      this._fooOptional = cdktf.TerraformStringAttribute.create(this, 'foo_optional', value);
    }
  }

  // foo_required - computed: false, optional: false, required: true
  private _fooRequired!: cdktf.TerraformStringAttribute;
  public get fooRequired() {
    return this._fooRequired;
  }
  public putFooRequired(value: cdktf.TerraformString) {
    this._fooRequired = cdktf.TerraformStringAttribute.create(this, 'foo_required', value);
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      foo_computed_optional: this._fooComputedOptional.toTerraform(),
      foo_optional: this._fooOptional.toTerraform(),
      foo_required: this._fooRequired.toTerraform(),
    };
  }
}
"
`;

exports[`reset and input name conflicts 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/name_conflict.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface NameConflictConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/name_conflict.html#values NameConflict#values}
  */
  readonly values?: cdktf.TerraformString;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/name_conflict.html#reset_values NameConflict#reset_values}
  */
  readonly resetValues?: cdktf.TerraformString;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/name_conflict.html#template NameConflict#template}
  */
  readonly template?: cdktf.TerraformString;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/name_conflict.html#template_input NameConflict#template_input}
  */
  readonly templateInput?: cdktf.TerraformString;
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/name_conflict.html aws_name_conflict}
*/
export class NameConflict extends cdktf.TerraformResource {

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/name_conflict.html aws_name_conflict} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options NameConflictConfig = {}
  */
  public constructor(scope: Construct, id: string, config: NameConflictConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_name_conflict',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this.putValues(config.values ?? new cdktf.TerraformStringAttribute(this, 'values', undefined));
    this.putResetValues(config.resetValues ?? new cdktf.TerraformStringAttribute(this, 'reset_values', undefined));
    this.putTemplate(config.template ?? new cdktf.TerraformStringAttribute(this, 'template', undefined));
    this.putTemplateInput(config.templateInput ?? new cdktf.TerraformStringAttribute(this, 'template_input', undefined));
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // values - computed: false, optional: true, required: false
  private _values!: cdktf.TerraformStringAttribute;
  public get values() {
    return this._values;
  }
  public putValues(value: cdktf.TerraformString | undefined) {
    if (value === undefined) {
      this._values.reset();
    }
    else {
      this._values = cdktf.TerraformStringAttribute.create(this, 'values', value);
    }
  }

  // reset_values - computed: false, optional: true, required: false
  private _resetValues!: cdktf.TerraformStringAttribute;
  public get resetValues() {
    return this._resetValues;
  }
  public putResetValues(value: cdktf.TerraformString | undefined) {
    if (value === undefined) {
      this._resetValues.reset();
    }
    else {
      this._resetValues = cdktf.TerraformStringAttribute.create(this, 'reset_values', value);
    }
  }

  // template - computed: false, optional: true, required: false
  private _template!: cdktf.TerraformStringAttribute;
  public get template() {
    return this._template;
  }
  public putTemplate(value: cdktf.TerraformString | undefined) {
    if (value === undefined) {
      this._template.reset();
    }
    else {
      this._template = cdktf.TerraformStringAttribute.create(this, 'template', value);
    }
  }

  // template_input - computed: false, optional: true, required: false
  private _templateInput!: cdktf.TerraformStringAttribute;
  public get templateInput() {
    return this._templateInput;
  }
  public putTemplateInput(value: cdktf.TerraformString | undefined) {
    if (value === undefined) {
      this._templateInput.reset();
    }
    else {
      this._templateInput = cdktf.TerraformStringAttribute.create(this, 'template_input', value);
    }
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      values: this._values.toTerraform(),
      reset_values: this._resetValues.toTerraform(),
      template: this._template.toTerraform(),
      template_input: this._templateInput.toTerraform(),
    };
  }
}
"
`;

exports[`set / list block type 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/block_type_set_list.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface BlockTypeSetListConfig extends cdktf.TerraformMetaArguments {
  /**
  * timeouts_set block
  * 
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/block_type_set_list.html#timeouts_set BlockTypeSetList#timeouts_set}
  */
  readonly timeoutsSet?: TerraformBlockTypeSetListTimeoutsSetSet;
  /**
  * timeouts_list block
  * 
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/block_type_set_list.html#timeouts_list BlockTypeSetList#timeouts_list}
  */
  readonly timeoutsList?: TerraformBlockTypeSetListTimeoutsListList;
}
export interface BlockTypeSetListTimeoutsSet {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/block_type_set_list.html#create BlockTypeSetList#create}
  */
  readonly create?: cdktf.TerraformString;
}

function blockTypeSetListTimeoutsSetToTerraform(struct?: BlockTypeSetListTimeoutsSet): any {
  if (!cdktf.canInspect(struct)) { return struct; }
  return {
    create: struct!.create.toTerraform(),
  }
}

export interface BlockTypeSetListTimeoutsList {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/block_type_set_list.html#create BlockTypeSetList#create}
  */
  readonly create?: cdktf.TerraformString;
}

function blockTypeSetListTimeoutsListToTerraform(struct?: BlockTypeSetListTimeoutsList): any {
  if (!cdktf.canInspect(struct)) { return struct; }
  return {
    create: struct!.create.toTerraform(),
  }
}


/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/block_type_set_list.html aws_block_type_set_list}
*/
export class BlockTypeSetList extends cdktf.TerraformResource {

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/block_type_set_list.html aws_block_type_set_list} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options BlockTypeSetListConfig = {}
  */
  public constructor(scope: Construct, id: string, config: BlockTypeSetListConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_block_type_set_list',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this.putTimeoutsSet(config.timeoutsSet ?? new TerraformBlockTypeSetListTimeoutsSetSetAttribute(this, 'timeouts_set', undefined));
    this.putTimeoutsList(config.timeoutsList ?? new TerraformBlockTypeSetListTimeoutsListListAttribute(this, 'timeouts_list', undefined));
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // timeouts_set - computed: false, optional: true, required: false
  private _timeoutsSet!: TerraformBlockTypeSetListTimeoutsSetSetAttribute;
  public get timeoutsSet() {
    return this._timeoutsSet;
  }
  public putTimeoutsSet(value: TerraformBlockTypeSetListTimeoutsSetSet | undefined) {
    if (value === undefined) {
      this._timeoutsSet.reset();
    }
    else {
      this._timeoutsSet = TerraformBlockTypeSetListTimeoutsSetSetAttribute.create(this, 'timeouts_set', value);
    }
  }

  // timeouts_list - computed: false, optional: true, required: false
  private _timeoutsList!: TerraformBlockTypeSetListTimeoutsListListAttribute;
  public get timeoutsList() {
    return this._timeoutsList;
  }
  public putTimeoutsList(value: TerraformBlockTypeSetListTimeoutsListList | undefined) {
    if (value === undefined) {
      this._timeoutsList.reset();
    }
    else {
      this._timeoutsList = TerraformBlockTypeSetListTimeoutsListListAttribute.create(this, 'timeouts_list', value);
    }
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      timeouts_set: this._timeoutsSet.toTerraform(),
      timeouts_list: this._timeoutsList.toTerraform(),
    };
  }
}
"
`;

exports[`single block type 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/single_block_type.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface SingleBlockTypeConfig extends cdktf.TerraformMetaArguments {
  /**
  * timeouts block
  * 
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/single_block_type.html#timeouts SingleBlockType#timeouts}
  */
  readonly timeouts?: TerraformSingleBlockTypeTimeouts;
}
export interface SingleBlockTypeTimeouts {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/single_block_type.html#create SingleBlockType#create}
  */
  readonly create?: cdktf.TerraformString;
}

function singleBlockTypeTimeoutsToTerraform(struct?: SingleBlockTypeTimeouts): any {
  if (!cdktf.canInspect(struct)) { return struct; }
  return {
    create: struct!.create.toTerraform(),
  }
}


/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/single_block_type.html aws_single_block_type}
*/
export class SingleBlockType extends cdktf.TerraformResource {

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/single_block_type.html aws_single_block_type} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options SingleBlockTypeConfig = {}
  */
  public constructor(scope: Construct, id: string, config: SingleBlockTypeConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_single_block_type',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this.putTimeouts(config.timeouts ?? new TerraformSingleBlockTypeTimeoutsAttribute(this, 'timeouts', undefined));
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // timeouts - computed: false, optional: true, required: false
  private _timeouts!: TerraformSingleBlockTypeTimeoutsAttribute;
  public get timeouts() {
    return this._timeouts;
  }
  public putTimeouts(value: TerraformSingleBlockTypeTimeouts | undefined) {
    if (value === undefined) {
      this._timeouts.reset();
    }
    else {
      this._timeouts = TerraformSingleBlockTypeTimeoutsAttribute.create(this, 'timeouts', value);
    }
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      timeouts: this._timeouts.toTerraform(),
    };
  }
}
"
`;

exports[`string list attribute 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/string_list.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface StringListConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/string_list.html#subject_alternative_names_optional_computed StringList#subject_alternative_names_optional_computed}
  */
  readonly subjectAlternativeNamesOptionalComputed?: cdktf.TerraformStringList;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/string_list.html#subject_alternative_names_required StringList#subject_alternative_names_required}
  */
  readonly subjectAlternativeNamesRequired: cdktf.TerraformStringList;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/string_list.html#subject_alternative_names_optional StringList#subject_alternative_names_optional}
  */
  readonly subjectAlternativeNamesOptional?: cdktf.TerraformStringList;
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/string_list.html aws_string_list}
*/
export class StringList extends cdktf.TerraformResource {

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/string_list.html aws_string_list} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options StringListConfig
  */
  public constructor(scope: Construct, id: string, config: StringListConfig) {
    super(scope, id, {
      terraformResourceType: 'aws_string_list',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this.putSubjectAlternativeNamesOptionalComputed(config.subjectAlternativeNamesOptionalComputed ?? new cdktf.TerraformStringListAttribute(this, 'subject_alternative_names_optional_computed', undefined));
    this._subjectAlternativeNamesComputed = new cdktf.TerraformStringListAttribute(this, 'subject_alternative_names_computed', undefined)
    this.putSubjectAlternativeNamesRequired(config.subjectAlternativeNamesRequired);
    this.putSubjectAlternativeNamesOptional(config.subjectAlternativeNamesOptional ?? new cdktf.TerraformStringListAttribute(this, 'subject_alternative_names_optional', undefined));
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // subject_alternative_names_optional_computed - computed: true, optional: true, required: false
  private _subjectAlternativeNamesOptionalComputed!: cdktf.TerraformStringListAttribute;
  public get subjectAlternativeNamesOptionalComputed() {
    return this._subjectAlternativeNamesOptionalComputed;
  }
  public putSubjectAlternativeNamesOptionalComputed(value: cdktf.TerraformStringList | undefined) {
    if (value === undefined) {
      this._subjectAlternativeNamesOptionalComputed.reset();
    }
    else {
      this._subjectAlternativeNamesOptionalComputed = cdktf.TerraformStringListAttribute.create(this, 'subject_alternative_names_optional_computed', value);
    }
  }

  // subject_alternative_names_computed - computed: true, optional: false, required: false
  private _subjectAlternativeNamesComputed: cdktf.TerraformStringListAttribute;
  public get subjectAlternativeNamesComputed() {
    return this._subjectAlternativeNamesComputed;
  }

  // subject_alternative_names_required - computed: false, optional: false, required: true
  private _subjectAlternativeNamesRequired!: cdktf.TerraformStringListAttribute;
  public get subjectAlternativeNamesRequired() {
    return this._subjectAlternativeNamesRequired;
  }
  public putSubjectAlternativeNamesRequired(value: cdktf.TerraformStringList) {
    this._subjectAlternativeNamesRequired = cdktf.TerraformStringListAttribute.create(this, 'subject_alternative_names_required', value);
  }

  // subject_alternative_names_optional - computed: false, optional: true, required: false
  private _subjectAlternativeNamesOptional!: cdktf.TerraformStringListAttribute;
  public get subjectAlternativeNamesOptional() {
    return this._subjectAlternativeNamesOptional;
  }
  public putSubjectAlternativeNamesOptional(value: cdktf.TerraformStringList | undefined) {
    if (value === undefined) {
      this._subjectAlternativeNamesOptional.reset();
    }
    else {
      this._subjectAlternativeNamesOptional = cdktf.TerraformStringListAttribute.create(this, 'subject_alternative_names_optional', value);
    }
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      subject_alternative_names_optional_computed: this._subjectAlternativeNamesOptionalComputed.toTerraform(),
      subject_alternative_names_required: this._subjectAlternativeNamesRequired.toTerraform(),
      subject_alternative_names_optional: this._subjectAlternativeNamesOptional.toTerraform(),
    };
  }
}
"
`;

exports[`string map attribute 1`] = `
"// https://www.terraform.io/docs/providers/aws/r/string_map.html
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface StringMapConfig extends cdktf.TerraformMetaArguments {
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/string_map.html#subject_alternative_names_computed_optional StringMap#subject_alternative_names_computed_optional}
  */
  readonly subjectAlternativeNamesComputedOptional?: cdktf.TerraformStringMap;
  /**
  * Docs at Terraform Registry: {@link https://www.terraform.io/docs/providers/aws/r/string_map.html#subject_alternative_names_optional StringMap#subject_alternative_names_optional}
  */
  readonly subjectAlternativeNamesOptional?: cdktf.TerraformStringMap;
}

/**
* Represents a {@link https://www.terraform.io/docs/providers/aws/r/string_map.html aws_string_map}
*/
export class StringMap extends cdktf.TerraformResource {

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://www.terraform.io/docs/providers/aws/r/string_map.html aws_string_map} Resource
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options StringMapConfig = {}
  */
  public constructor(scope: Construct, id: string, config: StringMapConfig = {}) {
    super(scope, id, {
      terraformResourceType: 'aws_string_map',
      terraformGeneratorMetadata: {
        providerName: 'aws'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle
    });
    this._subjectAlternativeNamesComputed = new cdktf.TerraformStringMapAttribute(this, 'subject_alternative_names_computed', undefined)
    this.putSubjectAlternativeNamesComputedOptional(config.subjectAlternativeNamesComputedOptional ?? new cdktf.TerraformStringMapAttribute(this, 'subject_alternative_names_computed_optional', undefined));
    this.putSubjectAlternativeNamesOptional(config.subjectAlternativeNamesOptional ?? new cdktf.TerraformStringMapAttribute(this, 'subject_alternative_names_optional', undefined));
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // subject_alternative_names_computed - computed: true, optional: false, required: false
  private _subjectAlternativeNamesComputed: cdktf.TerraformStringMapAttribute;
  public get subjectAlternativeNamesComputed() {
    return this._subjectAlternativeNamesComputed;
  }

  // subject_alternative_names_computed_optional - computed: true, optional: true, required: false
  private _subjectAlternativeNamesComputedOptional!: cdktf.TerraformStringMapAttribute;
  public get subjectAlternativeNamesComputedOptional() {
    return this._subjectAlternativeNamesComputedOptional;
  }
  public putSubjectAlternativeNamesComputedOptional(value: cdktf.TerraformStringMap | undefined) {
    if (value === undefined) {
      this._subjectAlternativeNamesComputedOptional.reset();
    }
    else {
      this._subjectAlternativeNamesComputedOptional = cdktf.TerraformStringMapAttribute.create(this, 'subject_alternative_names_computed_optional', value);
    }
  }

  // subject_alternative_names_optional - computed: false, optional: true, required: false
  private _subjectAlternativeNamesOptional!: cdktf.TerraformStringMapAttribute;
  public get subjectAlternativeNamesOptional() {
    return this._subjectAlternativeNamesOptional;
  }
  public putSubjectAlternativeNamesOptional(value: cdktf.TerraformStringMap | undefined) {
    if (value === undefined) {
      this._subjectAlternativeNamesOptional.reset();
    }
    else {
      this._subjectAlternativeNamesOptional = cdktf.TerraformStringMapAttribute.create(this, 'subject_alternative_names_optional', value);
    }
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      subject_alternative_names_computed_optional: this._subjectAlternativeNamesComputedOptional.toTerraform(),
      subject_alternative_names_optional: this._subjectAlternativeNamesOptional.toTerraform(),
    };
  }
}
"
`;
